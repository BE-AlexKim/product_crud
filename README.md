
## 1. 사고의 흐름

먼저 과제의 요구사항을 상세히 분석하여 핵심 기능을 파악하는 것이 가장 중요했습니다.
이번 과제에서는 상품 등록, 검토 프로세스, 번역 API 연동, 알림 시스템 등이 주요 기능이었습니다.
이를 기반으로 다음과 같은 질문을 던지면서 개발 방향을 정리했습니다.

- 상품 등록과 수정은 어떻게 관리할 것인가?
- 임시 저장된 상품을 다시 등록하는 경우를 어떻게 처리할 것인가?
- 상품의 상태가 변경될 때, 검토 프로세스는 어떤 방식으로 진행될 것인가?
- 번역 API 연동은 언제 이루어져야 하며, API 응답이 지연되거나 실패할 경우 어떻게 처리할 것인가?
- 작가에게 상품 검토 상태 변경 알림을 전송하는 로직을 어떤 방식으로 구현할 것인가?

요구사항을 바탕으로 데이터 모델을 설계했습니다.
이 과정에서는 정규화와 확장성을 고려한 설계가 중요했습니다.

이러한 구조를 통해 상품과 번역 데이터를 분리하여 관리하면서도
상품 상태 변경 시 자동으로 연관 프로세스를 처리할 수 있도록 설계했습니다.

설계 과정에서는 단일 책임 원칙(SRP)을 적용하여 서비스 계층을 분리하고, 
확장성을 고려한 구조를 유지하는 것이 중요했습니다.

상품의 상태가 변경될 때 번역 요청 및 알림 전송이 동시에 이루어져야 했습니다.
이를 위해 Spring의 ApplicationEventPublisher를 활용한 이벤트 기반 아키텍처를 적용했습니다.

## 2. 가정사항


1. 시스템 환경 및 기술 스택
기술 스택 가정: Spring Boot와 Kotlin을 사용한다는 점에서, Spring Boot의 기본 구조와 Kotlin의 특성을 이해하고 이를 기반으로 개발이 진행됩니다. 이때, 의존성 주입, 트랜잭션 관리, 예외 처리 등 Spring Boot의 기능을 어떻게 설정하고 사용할지에 대한 가정이 필요합니다.
외부 API 통합: 번역 API나 문자 메시지 발송 API와 같은 외부 시스템이 포함될 경우, 실제 API 호출을 구현하기 전에 API의 동작을 예상해야 합니다. 예를 들어, 번역 API의 응답 지연이나 실패 가능성에 대한 처리 로직을 가정해야 할 것입니다.


2. 데이터베이스 및 모델 설계
데이터베이스 설계: 상품, 사용자, 매니저 등의 정보가 어떻게 저장되고, 각 상태가 어떻게 관리되는지에 대한 설계가 필요합니다. 예를 들어, 상품의 상태를 관리하는 테이블과 각 상태 전환을 어떻게 처리할지에 대한 논의가 필요합니다.
상태 관리: 상품이 작성 중, 검토 요청, 검토 중, 검토 거절, 검토 완료 등 상태에 따라 어떻게 변화하는지, 각 상태 전환을 어떤 방식으로 처리할지에 대한 가정이 필요합니다.


3. 서비스 및 로직 처리
비즈니스 로직 분리: 서비스 계층과 컨트롤러 계층에서 어떤 로직을 처리할지에 대한 가정이 필요합니다. 예를 들어, 상품 등록, 검토 요청, 상태 전환 등의 비즈니스 로직은 서비스 계층에서 처리되고, 컨트롤러에서는 HTTP 요청을 받아서 서비스 계층을 호출하는 역할만 하도록 해야 합니다.
상태 변경 및 알림: 상품의 상태가 변경될 때마다 사용자나 매니저에게 알림을 보내는 부분에 대해서도 가정해야 합니다. 예를 들어, 검토 완료 후 작가에게 메시지를 전송하거나, 검토 거절 시 작가에게 이유를 전달하는 등.


4. 성능 및 확장성
트래픽 부하 고려: 실제 운영 환경에서의 성능을 고려하여, 시스템이 많은 사용자의 요청을 처리할 수 있도록 설계해야 합니다. 비동기 처리를 통해 외부 API 호출이나 대용량 데이터 처리를 효율적으로 할 수 있는 방법에 대해 고민이 필요합니다.
멀티스레딩 및 비동기 처리: 외부 API 호출이나 긴 시간이 소요되는 작업을 비동기적으로 처리할 수 있는 구조가 필요합니다. 예를 들어, 상품 상태 변경 시 번역 API를 호출하고 그 결과를 반영하는 로직에서 비동기 처리가 필요할 수 있습니다.


5. 예외 처리 및 장애 대응
예외 처리 전략: 시스템에서 발생할 수 있는 예외에 대해 일관되게 처리하는 방법을 가정해야 합니다. 예를 들어, 외부 API 호출이 실패했을 때의 재시도 처리, 예상치 못한 예외가 발생했을 때의 처리 방법, 예외를 사용자에게 어떻게 전달할지 등에 대해 고민해야 합니다.
예외 발생 시 처리: API 호출이 실패하거나 내부 처리에서 오류가 발생할 경우, 적절한 오류 메시지를 반환하고 로그를 남기는 방식으로 예외를 처리할 수 있는 구조가 필요합니다.


6. 보안 및 인증
보안 가정: 시스템에서 중요한 데이터나 민감한 정보를 다룰 경우, 보안적인 측면도 고려해야 합니다. 예를 들어, 사용자의 인증 및
권한 관리를 어떻게 할지, 민감한 데이터를 암호화할지 등에 대해 고민해야 합니다.
JWT 사용: 사용자의 인증을 처리하는 방법으로 JWT를 사용하여 권한 관리 처리 방법에 대해서 가정해볼 수 있습니다..

## 3. 고려 사항

1. 상품 등록
- 상품 등록의 경우 작가 권한의 사용자만 등록할 수 있으며, 상품을 등록할때, 임시 저장이 가능하다. 
- 상품 등록 진행 시, 오류가 발생하면 적절한 응답과 함께 로그를 남긴다.
- 상품 등록 시, 임시저장의 경우, 미입력 데이터가 있더라도 저장이 되어야 한다.
- 작가는 상품을 한국어로 작성한다.


2. 상품 수정
- 작가 권한의 경우, 임시 저장 상태의 경우 수정이 자유롭다. 
- 상품 수정 진행 시, 오류가 발생하면 적절한 응답과 함께 로그를 남긴다.
- 매니저 권한의 사용자는 검토가 거절된 상태의 상품은 수정할 수 있다.
- 상품의 상태가 검토 거절인 경우, 본문과 제목이 수정될 때 번역 API를 이용해야 한다.
- 작가는 검토 완료 된 상품의 내용을 수정해서 검토 요청으로 매니저에게 요청할 수 있다.

3. 상품 검토 요청
- 상품의 검토 요청은 작가 권한의 사용자만 가능하다.
- 상품 검토 요청 시, 데이터가 모두 입력되어있는지 상태값을 체크한다.
- 작가는 검토 거절된 상품의 내용을 수정해서 검토 요청을 진행할 수 있다.

4. 상품 검토 중 상태 변경 요청
- 매니저는 검토 요청된 상품의 상태를 검토중으로 변경할 수 있다.
- 매니저가 검토 중으로 상태를 변경 시, 작가에게 문자메시지를 발송한다.
- 검토 중으로 변경 시, 제목 및 본문 등 사용자에게 노출되는 메시지를 번역하여 영어/일본어판도 소유할 수 있다.
- 언어 번역 시, 일정확률로 API가 실패할 수 있다.

5. 상품 검토 거절 요청
- 매니저 권한의 사용자만 해당 엔드포인트를 사용할 수 있다.
- 상품이 거절될 경우, 작가에게 문자메세지를 보낸다.
- 매니저는 거절 사유를 선택적으로 작성할 수 있다.
- 검토가 거절된 사유가 존재한다면, 문자 메세지로 함께 전송한다.
- 검토 거절 시, 검토 중에서 생성된 번역문을 삭제한다. 

6. 검토 완료 상태값 변경
- 검토 완료 시, 작가에게 검토가 완료되었다는 문자 메세지를 보내게 됩니다.

7. 상품 조회
- 작가는 임시저장된 상품, 검토 요청 중인 상품, 검토 중인 상품을 조회할 수 있다.
- 매니저는 임시저장된 상태의 상품을 제외한 모든 상태의 상품을 조회할 수 있다.
- 매니저는 조회 시, 이름,상태,제목으로 필터링, 정렬, 페이지네이션이 가능해야 한다.
- 상품 조회 시, 언어값으로 해당 상품을 조회할 수 있다.
- 고객은 검토가 완료된 상품만 조회할 수 있다.

8. 상품 상세 조회
- 매니저는 검토 요청 및 검토 거절의 상태의 상세 정보를 확인할 수 있다.
- 고객은 검토 완료된 상품의 단일 상품의 상세정보를 조회할 수 있습니다.

### 4. 특이 사항
```

```
### 5. 코드 구조 선택과 근거
#### 1. comn 패키지
- security: 보안 관련 클래스들 (예: 인증, 권한 관리 등)
- exceptionHandler: 예외 처리 관련 클래스들 (예: 글로벌 예외 처리)
- customException: 사용자 정의 예외들
- Swagger: Swagger 설정 및 문서화
- AsyncConfig: 비동기 처리 설정

1. 재사용성: comn 패키지는 애플리케이션 전체에서 공통으로 사용되는 기능들을 포함합니다. 보안, 예외 처리, 
Swagger 설정 등은 모든 기능에서 필요하기 때문에 이를 별도의 패키지로 묶어 관리하는 것이 좋습니다. 
이렇게 하면 각 기능별 패키지에 의존하지 않고 공통적인 설정을 모듈화할 수 있어 재사용성이 높아집니다. 


2. 책임 분리: comn 패키지는 애플리케이션의 핵심 기능을 지원하는 공통적인 부분들을 포함합니다. 
이를 통해 기능별 책임 분리를 유지하면서, 보안, 예외 처리 등의 공통적인 부분을 한 곳에서 관리할 수 있습니다. 
각 기능별 패키지에서는 이를 불러와 사용할 수 있습니다.


3. 구성의 일관성: comn 패키지는 애플리케이션의 핵심 인프라스트럭처나 설정을 담당합니다. 보안 처리, 
예외 관리와 같은 부분은 모든 API에서 공통적으로 필요하기 때문에 이를 하나의 패키지에 모아서 구성의 일관성을 유지할 수 있습니다.

#### 2. api 패키지: 기능별 모듈화
구성
- product, user, translate, message 등 기능별로 분리된 패키지
- 각 패키지 내에는 service, serviceImpl, repository, controller, model, validator, filter 등 관련 클래스들

근거
- 기능 단위로 분리: api 패키지는 각 기능별로 모듈화되어 있습니다. 예를 들어, product 패키지에는 상품과 관련된 
모든 클래스들이 포함되며, user 패키지에는 사용자와 관련된 클래스들이 포함됩니다. 이렇게 모듈화된 구조는 각 기능을 
독립적으로 개발, 테스트, 배포할 수 있게 하며, 확장성을 높입니다.


- 단일 책임 원칙(SRP): 각 패키지는 해당 기능에 관련된 책임만을 담당합니다. 예를 들어, product 패키지 내의 service는 
상품 관련 비즈니스 로직만 처리하고, controller는 HTTP 요청을 처리하는 역할만 합니다. 이를 통해 각 클래스의 책임을 분리하고,
코드의 가독성과 유지보수성을 높일 수 있습니다.


- 유지보수 용이성: 각 기능별로 패키지를 나누면, 특정 기능을 변경하거나 확장할 때 해당 패키지 내에서만 작업하면 됩니다.
예를 들어, product 관련 기능에서 변경 사항이 생기면, product 패키지 내의 클래스들만 수정하면 되어 변경 범위를 최소화할
수 있습니다.


- 계층화된 구조: 각 기능별 패키지 내에서 service, serviceImpl, repository, controller 등으로 계층화하여 
각 역할을 분리함으로써 클린 아키텍처 또는 계층형 아키텍처를 따를 수 있습니다. 이 구조는 각 계층이 다른 계층에 의존하는 
방식으로 설계되어 유연성과 테스트 용이성을 높입니다.

결론

- 위와 같은 코드 구조는 유지보수성, 확장성, 책임 분리 등의 원칙을 지키기 위해 설계되었습니다. comn 패키지는 공통 기능을 처리하고, api 패키지는 기능 단위로 분리하여 각 기능의 독립성과 테스트 용이성을 높였습니다. 각 기능별 패키지 내에서 서비스 계층, 데이터 접근 계층, 검증 계층 등을 명확히 분리하여 클린 코드와 모듈화를 달성할 수 있습니다.

## 6. ERD/UML Practice

### 주요 엔티티 정의
#### Product (상품 엔티티)
- 상품의 기본 정보 (제목, 본문, 가격 등)
- 상품의 상태 (작성 중, 검토 요청, 검토 중, 검토 거절, 검토 완료)
- 작성자 정보 (작가 ID)

#### Translate (번역 엔티티)
- 번역된 제목 및 본문 저장 
- 번역 대상 언어 (ISO-639 코드 사용)
- 번역 코드(상품의 원본과 매핑하기 위한 식별값)

#### User (사용자 엔티티)
- 사용자 역할 (작가, 매니저, 고객)

#

### 7. 시행착오 및 피드백 (힘들었던 점, 개선하면 좋겠다고 생각하는 점)
```
과제를 진행하며 여러 가지 고민이 있었습니다. 특히 SOLID 원칙을 고려하여 개발하다 보니,
확장성에 대한 고민이 자연스럽게 따랐습니다.

우선, 상품 등록과 수정 로직에서 구조를 어떻게 가져가야 할지에 대한 고민이 컸습니다.
상품을 등록하는 과정에서 새롭게 작성하여 등록하는 경우와 임시 저장된 항목을 다시 저장하는 
경우가 존재하는데,이 두 가지 경우를 하나의 엔드포인트에서 처리하는 것이 적절한지, 아니면 
분리하는 것이 더 나은 방법인지 신중하게 고민해야 했습니다. 특히, 등록과 수정이 함께 이루어지는
서비스 로직을 어떻게 설계해야 단일 책임 원칙을 지키면서도 복잡도를 줄일 수 있을지가 중요한 
고려 사항이었습니다.

또한, 외부 API 연동에 대한 어려움도 있었습니다. 번역 API 및 알림 메시지 전송 API는 요청과 
응답을 예측할 수 있었지만, 실제로 동작하지 않는 환경에서 구현해야 했기 때문에 예상 가능한 
범위까지만 적용할 수 있었습니다. 특히, 번역 API의 경우 일정 확률로 응답이 실패하거나 지연될 
가능성이 있어, 이러한 예외 상황을 어떻게 처리할지에 대한 고민이 필요했습니다.

검토 상태 변경 시 작가에게 메시지를 보내는 로직 또한 고민이 필요했던 부분이었습니다.
상품이 "검토 중", "검토 거절", "검토 완료" 상태로 변경될 때 자동으로 알림을 발송하는 것이 
적절한지, 아니면 별도의 트리거를 두어야 하는지에 대한 명확한 기준을 정하는 것이 필요했습니다.
이 부분은 실제 운영 환경에서의 요구사항을 더 구체적으로 정의한 후 개선해야 할 것으로 보입니다.

과제를 진행하면서 너무 복잡하게 생각한게 아닌가하는 아쉬움이 있습니다. 기존에 스타트업을 다니면서 
TDD를 하면서 진행해본적이 없다보니 미숙한 부분이 있는 부분이 너무나도 아쉽습니다.

기존에 다국어를 진행할때에는 message.bunddle을 사용해서 진행했었는데 번들은 동적으로 사용하기에는
너무나도 불편한 점이 많기 때문에 데이터베이스를 기반에 두고 QueryDSL을 사용해서 쿼리 성능을 높히게 되면
좋을 것이라 생각되어 시도해보았지만, 데이터 구조 자체를 초반에 제대로 설계하고 들어갔다면 
좋지 않았을까하는 아쉬움 또한 있습니다.

마지막으로, 데이터베이스 구조에 대한 고민도 있었습니다. 현재 설계된 구조가 확장성을 고려했을 때 적절한지,
또한 추후 새로운 요구사항이 추가될 경우에도 유연하게 대응할 수 있는지를 점검할 필요가 있었습니다.

전반적으로 이번 과제를 통해 SOLID 원칙을 준수하면서 개발하는 과정과 확장성을 고려한 설계의 중요성을 
다시 한번 경험할 수 있었습니다. 단순한 기능 구현을 넘어, 유지보수성과 확장성을 고려한 개발이 
얼마나 중요한지 다시금 깨닫는 좋은 기회가 되었습니다.

```
